<svelte:options runes={true} />

<script context="module">
  const baseWidth = 57.6;
  const distanceLimit = baseWidth * 6;
  const beyondTheDistanceLimit = distanceLimit + 1;
  const distanceInput = [
    -distanceLimit,
    -distanceLimit / 1.25,
    -distanceLimit / 2,
    0,
    distanceLimit / 2,
    distanceLimit / 1.25,
    distanceLimit,
  ];
  const widthOutput = [
    baseWidth,
    baseWidth * 1.1,
    baseWidth * 1.414,
    baseWidth * 2,
    baseWidth * 1.414,
    baseWidth * 1.1,
    baseWidth,
  ];
</script>

<script lang="ts">
  import { interpolate } from 'popmotion';
  import { onDestroy, untrack } from 'svelte';
  import { sineInOut } from 'svelte/easing';
  import { tweened } from 'svelte/motion';
  import { elevation } from 'üçé/actions';
  import { appsConfig } from 'üçé/configs/apps/apps-config';
  import { spring } from 'üçé/state/spring.svelte.ts';
  import { apps_store, type AppID } from 'üçé/state/apps.svelte';
  import { prefersReducedMotion } from 'üçé/stores/prefers-motion.store';
  import { theme } from 'üçé/stores/theme.store';

  const {
    mouseX,
    appID,
    needs_update = false,
  }: {
    mouseX: number | null;
    appID: AppID;
    needs_update: boolean;
  } = $props();

  let imageEl = $state<HTMLImageElement>();

  let distance = $state(beyondTheDistanceLimit);

  const widthPX = spring(baseWidth, {
    damping: 0.47,
    stiffness: 0.12,
  });

  const getWidthFromDistance = interpolate(distanceInput, widthOutput);

  $effect(() => {
    distance;

    untrack(() => (widthPX.value = getWidthFromDistance(distance)));
  });

  let raf: number;
  function animate() {
    if (imageEl && mouseX !== null) {
      const rect = imageEl.getBoundingClientRect();

      // get the x coordinate of the img DOMElement's center
      // the left x coordinate plus the half of the width
      const imgCenterX = rect.left + rect.width / 2;

      // difference between the x coordinate value of the mouse pointer
      // and the img center x coordinate value
      const distanceDelta = mouseX - imgCenterX;
      distance = distanceDelta;
      return;
    }

    distance = beyondTheDistanceLimit;
  }

  $effect(() => {
    mouseX;
    if ($prefersReducedMotion || apps_store.is_being_dragged) return;

    raf = requestAnimationFrame(animate);
  });

  const { title, shouldOpenWindow, externalAction } = appsConfig[appID];

  // Spring animation for the click animation
  const appOpenIconBounceTransform = tweened(0, {
    duration: 400,
    easing: sineInOut,
  });

  async function bounceEffect() {
    // Animate the icon
    await appOpenIconBounceTransform.set(-40);

    // Now animate it back to its place
    appOpenIconBounceTransform.set(0);
  }

  async function openApp(e: MouseEvent) {
    if (!shouldOpenWindow) return externalAction?.(e);

    // For the bounce animation
    const isAppAlreadyOpen = apps_store.open[appID];

    apps_store.open[appID] = true;
    apps_store.active = appID;

    if (isAppAlreadyOpen) return;

    bounceEffect();
  }

  onDestroy(() => {
    cancelAnimationFrame(raf);
  });

  const is_app_store = $derived(appID === 'appstore');
  const show_pwa_badge = $derived(is_app_store && needs_update);

  $effect(() => {
    if (show_pwa_badge) bounceEffect();
  });
</script>

<button onclick={openApp} aria-label="Launch {title} app" class="dock-open-app-button {appID}">
  <p
    class="tooltip"
    class:tooltip-enabled={!apps_store.is_being_dragged}
    class:dark={$theme.scheme === 'dark'}
    style:top={$prefersReducedMotion ? '-50px' : '-35%'}
    style:transform="translate(0, {$appOpenIconBounceTransform}px)"
    use:elevation={'dock-tooltip'}
  >
    {title}
  </p>

  <span style:transform="translate(0, {$appOpenIconBounceTransform}px)">
    <img
      bind:this={imageEl}
      src="/app-icons/{appID}/256.webp"
      alt="{title} app"
      style:width="{widthPX.value / 16}rem"
      draggable="false"
    />
  </span>

  <div class="dot" style:--opacity={+apps_store.open[appID]}></div>

  {#if show_pwa_badge}
    <div class="pwa-badge" style:transform="scale({widthPX.value / baseWidth})">1</div>
  {/if}
</button>

<style lang="scss">
  img {
    will-change: width;
  }

  button {
    display: flex;
    flex-direction: column;
    justify-content: flex-end;
    position: relative;

    border-radius: 0.5rem;

    &:hover,
    &:focus-visible {
      .tooltip.tooltip-enabled {
        display: block;
      }
    }

    & > span {
      display: flex;
      justify-content: center;
      align-items: center;
    }
  }

  .tooltip {
    --double-border: 0 0 0 0 white;

    white-space: nowrap;

    position: absolute;

    background-color: hsla(var(--system-color-light-hsl), 0.5);
    backdrop-filter: blur(5px);

    padding: 0.5rem 0.75rem;
    border-radius: 0.375rem;

    box-shadow:
      hsla(0deg, 0%, 0%, 30%) 0px 1px 5px 2px,
      var(--double-border);

    color: var(--system-color-light-contrast);
    font-family: var(--system-font-family);
    font-weight: 400;
    font-size: 0.9rem;
    letter-spacing: 0.4px;

    display: none;

    &.dark {
      --double-border: inset 0 0 0 0.9px hsla(var(--system-color-dark-hsl), 0.3),
        0 0 0 1.2px hsla(var(--system-color-light-hsl), 0.3);
    }
  }

  .dot {
    height: 4px;
    width: 4px;

    margin: 0px;

    border-radius: 50%;

    background-color: var(--system-color-dark);

    opacity: var(--opacity);
  }
  .pwa-badge {
    position: absolute;
    top: 1px;
    right: -1px;

    background-color: rgba(248, 58, 58, 0.85);

    box-shadow: hsla(var(--system-color-dark-hsl), 0.4) 0px 0.5px 2px;
    border-radius: 50%;

    pointer-events: none;
    vertical-align: middle;

    width: 1.5rem;
    height: 1.5rem;

    margin: 0;
    padding: 0;

    text-align: center;
    color: white;

    font-size: 1rem;
    line-height: 1.5;
  }
</style>
